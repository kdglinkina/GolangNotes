package main

import (
	"fmt"
	"math"
)

func main() {
	//Значения
	//Строки можно складывать через +:
	fmt.Println("go" + "lang")
	// golang

	//Целые и дробные числа:
	fmt.Println("1+1 =", 1+1)
	// 1+1 = 2

	fmt.Println("7.0/3.0 =", 7.0/3.0)
	// 7.0/3.0 = 2.3333333333333335

	//Логические значения и операторы:
	fmt.Println(true && false)
	// false

	fmt.Println(true || false)
	// true

	fmt.Println(!true)
	// false

	//Переменные
	//Go статически типизирован. Переменные явно объявляются, типы заранее известны компилятору.

	//var объявляет переменную, = инициализирует конкретным значением:
	var a = "initial"
	fmt.Println(a)
	// initial

	//Можно объявить сразу несколько:
	var b, c int = 1, 2
	fmt.Println(b, c)
	// 1 2

	//Если инициализировать переменную при объявлении, тип можно и не указывать. Go сам догадается:
	var d = true
	fmt.Printf("%v is %T\n", d, d)
	// true is bool

	//fmt.Printf() подставляет переменные в строку по шаблону. %v — формат по умолчанию, %T — тип переменной.

	//Если не инициализировать переменную при объявлении, она получит нулевое значение.
	//У каждого типа оно свое. У int, например, 0:
	var e int
	fmt.Println(e)
	// 0

	//Оператор := объявляет и инициализирует переменную. var и тип можно не указывать:
	f := "apple" // var f string = "apple"
	fmt.Println(f)
	// apple

	//Константы
	//Go поддерживает константы для символов, строк, логических и числовых значений.
	//const объявляет константу:

	const s string = "constant"
	fmt.Println(s)
	// constant

	const n = 500000000
	fmt.Println(n)
	// 500000000

	const ch = 'a'
	fmt.Println(ch)
	// 97
	// это числовой код латинского символа 'a'

	//Если указать выражение — Go рассчитает и сохранит результат.
	//В выражении можно использовать объявленные ранее константы:
	const p = 3e20 / n
	fmt.Println(p)
	// 6e+11

	//Тип числовой константы определяется из контекста. Например, когда есть явное приведение типа:
	fmt.Println(int64(p))
	// 600000000000

	//Или функция, которая требует значение определенного типа (math.Sin() ожидает float64):
	fmt.Println(math.Sin(n))
	// -0.28470407323754404

	//Циклы
	//for — единственная конструкция для циклов в Go. Вот несколько примеров.
	//С одним условием, аналог while в питоне:
	i := 1
	for i <= 3 {
		fmt.Println(i)
		i = i + 1
	}
	// 1
	// 2
	// 3

	//Классический for из трех частей (инициализация, условие, шаг):
	for j := 7; j <= 9; j++ {
		fmt.Println(j)
	}
	// 7
	// 8
	// 9

	//Бесконечный цикл, выполняется до break для выхода из цикла или return для выхода из функции:
	for {
		fmt.Println("loop")
		break
	}
	// loop

	//continue переходит к следующей итерации цикла:
	for n := 0; n <= 5; n++ {
		if n%2 == 0 {
			continue
		}
		fmt.Println(n)
	}
	// 1
	// 3
	// 5

	//If/else
	//Конструкция if-else в Go ведет себя без особых сюрпризов.

	//Вокруг условия не нужны круглые скобки, но фигурные скобки для веток обязательны:
	if 7%2 == 0 {
		fmt.Println("7 is even")
	} else {
		fmt.Println("7 is odd")
	}
	// 7 is odd

	//Можно использовать if без else:
	if 8%4 == 0 {
		fmt.Println("8 is divisible by 4")
	}
	// 8 is divisible by 4

	//Единственный нюанс: перед условием может идти выражение. Объявленные в нем переменные доступны во всех ветках:
	if num := 9; num < 0 {
		fmt.Println(num, "is negative")
	} else if num < 10 {
		fmt.Println(num, "has 1 digit")
	} else {
		fmt.Println(num, "has multiple digits")
	}
	// 9 has 1 digit

	switch i {
	case 0:
		fmt.Println("Zero")
	case 1:
		fmt.Println("One")
	case 2:
		fmt.Println("Two")
	case 3:
		fmt.Println("Three")
	case 4:
		fmt.Println("Four")
	case 5:
		fmt.Println("Five")
	default:
		fmt.Println("Unknown Number")
	}
	//Переключатель начинается с ключевого слова switch, за которым следует выражение (в нашем случае i)
	//и серия возможных значений (case). Значение выражения по очереди сравнивается с выражениями,
	//следующими после ключевого слова case. Если они оказываются равны, то выполняется действие, описанное после.

}
